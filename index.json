[{"content":"because ++i use less memory.\n// prefix T\u0026amp; T::operator++(){ *this += 1; // or sth else return *this; } // postfix T\u0026amp; T::operator++(int){ // need to create a new variable T tmp(*this); // T tmp = *this ++(*this); return tmp; } 但是，编译器会对这种情况进行优化，所以实际上，这两种写法多数情况下在速度上是没有区别的。\n","permalink":"https://lysandert.github.io/posts/blog/why_use_++i/","summary":"because ++i use less memory. // prefix T\u0026amp; T::operator++(){ *this += 1; // or sth else return *this; } // postfix T\u0026amp; T::operator++(int){ // need to create a new variable T tmp(*this); // T tmp = *this ++(*this); return tmp; } 但是，编译器会对这种情况进行优化，所以实际上，这两种写法多数情况下在速度上是没有区别的。","title":"why is better to use ++i instead of i++ in a for loop"},{"content":"标签 新建标签：command + t\n关闭标签：command + w\n切换标签：\ncommand + 数字 1/2\ncommand + 左右方向键\n切换全屏：command + enter\n查找：command + f\n分屏 新建垂直分屏：command + d\n新建水平分屏：command + shift + d\n切换屏幕：command + option + 方向键 command + [ 或 command + ]\n查看历史命令：command + ;\n查看剪贴板历史：command + shift + h\n其他 清屏1：command + r\n清屏2：ctrl + l\n清除当前行：ctrl + u\n到行首：ctrl + a\n到行尾：ctrl + e\n前进后退：ctrl + f/b (相当于左右方向键)\n上一条命令：ctrl + p\n搜索命令历史：ctrl + r\n删除当前光标的字符：ctrl + d\n删除光标之前的字符：ctrl + h\n删除光标之前的单词：ctrl + w\n删除到文本末尾：ctrl + k\n交换光标处文本：ctrl + t\n","permalink":"https://lysandert.github.io/posts/blog/iterm2/","summary":"标签 新建标签：command + t 关闭标签：command + w 切换标签： command + 数字 1/2 command + 左右方向键 切换全屏：command + enter 查找：command + f 分屏 新建垂直分屏：command + d 新建水平分屏：command + shift + d 切换屏幕：command + option + 方向键 command + [ 或 command + ] 查看历史命令","title":"iTerm2 常用快捷键"},{"content":"run from terminal\nmysql -uroot -p \u0026gt;\u0026gt; 输入密码 attention 命令、检索均不区分大小写。习惯上将命令关键字大写，也可以通过配置sql让检索区分大小写 basic # 显示库列表 show databases; # 创建新库 create database \u0026lt;d_name\u0026gt;; # 使用这个库 use \u0026lt;d_name\u0026gt;; # 显示表列表 show tables; # 显示列（col）列表 show columns from \u0026lt;table_name\u0026gt;; describe \u0026lt;col_name\u0026gt;; select 无序检索 # select关键字 select \u0026lt;col_name1\u0026gt;, \u0026lt;col_name2\u0026gt;, ... from \u0026lt;table_name\u0026gt;; # a single col is also valid # * means all (like in python) select * from \u0026lt;table_name\u0026gt;; # 从start(index从0开始,默认0，可选参数)开始选length行 select \u0026lt;col_name1\u0026gt; from \u0026lt;table_name\u0026gt; limit (start,) length; # 完全限定 select \u0026lt;table_name\u0026gt;.\u0026lt;col_name\u0026gt; from \u0026lt;d_name\u0026gt;.\u0026lt;table_name\u0026gt;; 排序检索 # order by 关键字 # 先按col_3排序，如果并列则按col_4 # 默认升序(A-Z)，加DESC转换某[一列]为降序 select \u0026lt;col_1\u0026gt;, \u0026lt;col_2\u0026gt; , ... from \u0026lt;table_name\u0026gt; order by \u0026lt;col_3\u0026gt; DESC, \u0026lt;col_4\u0026gt;; 过滤检索 操作符 =, !=, \u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;= \u0026lt;\u0026gt; 相当于!= BETWEEN a AND b IS NULL 空值检查 # where 关键字 select \u0026lt;col\u0026gt; from \u0026lt;table\u0026gt; where \u0026lt;col2\u0026gt; = \u0026#39;lysander\u0026#39;; # 值可以是数值也可以是字符串（用单引号） SELECT \u0026lt;col\u0026gt; FROM \u0026lt;table\u0026gt; WHERE \u0026lt;col_\u0026gt; BETWEEN 5 AND 10; 逻辑运算符 AND 和，优先级高于OR，可用圆括号（）改变优先级 OR IN，用到圆括号()；可实现OR的功能，但速度更快，也有更多其他功能比如包含SELECT语句 NOT 否定它后面的一切条件，可用于找出与条件不匹配的行 SELECT \u0026lt;col\u0026gt; FROM \u0026lt;table\u0026gt; WHERE \u0026lt;col1\u0026gt; IN (3,4,5,6) AND \u0026lt;col2\u0026gt; \u0026gt;= 10; 通配符(模糊匹配) 需要先用LIKE操作符\n% 表示任何字符出现任意次数（包括0次） _ 表示任何字符出现exactly一次 # % # 以str开头的 SELECT prod_id, prod_name FROM products WHERE prod_name LIKE \u0026#39;str%\u0026#39;; # 以str结尾的 SELECT prod_id, prod_name FROM products WHERE prod_name LIKE \u0026#39;%str\u0026#39;; # str在中间的 SELECT prod_id, prod_name FROM products WHERE prod_name LIKE \u0026#39;%str%\u0026#39;; # 以str1开头，以str2结尾的 SELECT prod_id, prod_name FROM products WHERE prod_name LIKE \u0026#39;str1%str2\u0026#39;; # _用法与%相同，也可组合使用 SELECT prod_id, prod_name FROM products WHERE prod_name LIKE \u0026#39;%str_\u0026#39;; 正则表达式 关键字REGEXP(regular expression)\n# 基本字符匹配-所有包含\u0026#39;1000\u0026#39;的 SELECT prod_name FROM products WHERE prod_name REGEXP \u0026#39;1000\u0026#39;; # dot表示匹配任意**一个**字符 REGEXP \u0026#39;.000\u0026#39;; # 可见1000和2000都会被筛选出（虽然这个例子里面加不加dot都不会对结果有影响） +--------------+ | prod_name | +--------------+ | JetPack 1000 | | JetPack 2000 | +--------------+ # OR REGEXP \u0026#39;1000|2000\u0026#39; # 匹配几个字符之一 REGEXP \u0026#39;[123] ton\u0026#39; +-------------+ | prod_name | +-------------+ | 1 ton anvil | | 2 ton anvil | +-------------+ # 匹配范围 REGEXP \u0026#39;[1-3] ton\u0026#39; # 等价上一句 REGEXP \u0026#39;[a-z]\u0026#39; # 转义符用// REGEXP \u0026#39;//.\u0026#39; # 表示检索dot 匹配字符类\n[:alnum:] 任意字母和数字（同[a-zA-Z0-9]） [:alpha:] 任意字符（同[a-zA-Z]） [:blank:] 空格和制表（同[\\t]） [:cntrl:] ASCII控制字符（ASCII 0到31和127） [:digit:] 任意数字（同[0-9]） [:graph:] 与[:print:]相同，但不包括空格 [:lower:] 任意小写字母（同[a-z]） [:print:] 任意可打印字符 [:punct:] 既不在[:alnum:]又不在[:cntrl:]中的任意字符 [:space:] 包括空格在内的任意空白字符（同[\\f\\n\\r\\t\\v]） [:upper:] 任意大写字母（同[A-Z]） [:xdigit:] 任意十六进制数字（同[a-fA-F0-9]） 匹配多个实例\n* 0个或多个匹配 + 1个或多个匹配（等于{1,}） ? 0个或1个匹配（等于{0,1}） {n} 指定数目的匹配 {n,} 不少于指定数目的匹配 {n,m} 匹配数目的范围（m不超过255） # 示例 SELECT prod_name FROM products WHERE prod_name REGEXP \u0026#39;\\\\([0-9] sticks?\\\\)\u0026#39; order by prod_name; +----------------+ | prod_name | +----------------+ | TNT (1 stick) | | TNT (5 sticks) | +----------------+ SELECT prod_name FROM products WHERE prod_name REGEXP \u0026#39;[[:digit:]]{4}\u0026#39; order by prod_name; SELECT prod_name FROM products WHERE prod_name REGEXP \u0026#39;[0-9][0-9][0-9][0-9]\u0026#39; order by prod_name; # 两者等价 +--------------+ | prod_name | +--------------+ | JetPack 1000 | | JetPack 2000 | +--------------+ 定位符\n^ 文本的开始 $ 文本的结尾 [[:\u0026lt;:]] 词的开始 [[:\u0026gt;:]] 词的结尾 # 示例 SELECT name FROM person_tbl WHERE name REGEXP \u0026#39;^[aeiou]|ok$\u0026#39;; # 查找name字段中以元音字符开头或以\u0026#39;ok\u0026#39;字符串结尾的所有数据 todo ","permalink":"https://lysandert.github.io/posts/blog/mysql/","summary":"run from terminal mysql -uroot -p \u0026gt;\u0026gt; 输入密码 attention 命令、检索均不区分大小写。习惯上将命令关键字大写，也可以通过配置sql让检索区分大小写 basic # 显示库列表 show databases; # 创建新库 create database \u0026lt;d_name\u0026gt;; # 使用这个库 use \u0026lt;d_name\u0026gt;; # 显示表列表 show tables; # 显示列（col）列表 show columns from \u0026lt;table_name\u0026gt;; describe \u0026lt;col_name\u0026gt;; select 无序检索 # select关键字 select \u0026lt;col_name1\u0026gt;, \u0026lt;col_name2\u0026gt;, ... from \u0026lt;table_name\u0026gt;; # a single col is also valid # * means all (like in python)","title":"MySQL 常用命令"},{"content":"安装 命令行中输入\n# 若安装了python pip包 pip install mycli # or 安装了homebrew brew install mycli 使用 # 登录 mycli -u \u0026lt;user\u0026gt; -h \u0026lt;host\u0026gt; -p \u0026lt;password\u0026gt; #查看帮助 mycli --help # 若只是连接本地mysql mycli -uroot -p \u0026lt;password\u0026gt; # 其余命令皆和mysql语法一样 显示 ","permalink":"https://lysandert.github.io/posts/blog/mycli/","summary":"安装 命令行中输入 # 若安装了python pip包 pip install mycli # or 安装了homebrew brew install mycli 使用 # 登录 mycli -u \u0026lt;user\u0026gt; -h \u0026lt;host\u0026gt; -p \u0026lt;password\u0026gt; #查看帮助 mycli --help # 若只是连接本地mysql mycli -uroot -p \u0026lt;password\u0026gt; # 其余命令皆和mysql语法一样 显示","title":"Mycli-MySQL办公利器"},{"content":"折腾了半天，终于学会怎么在博客中插入图片了。\n这里记录一下解决办法\n插入图片：相对路径存在的问题 这是根目录结构：\ncontent -posts --blog 没有blog这一级结构的可以直接无视\n当我们用hugo指令：\nhugo new posts/blog/article.md 生成新文章后hugo会自动在blog文件夹下面创建一个md文件：\ncontent -posts --blog ---article.md 我们需要的是生成一个与article.md平级的文件夹用于存放要用到的图片，比如叫pic。 将想要插入的图片放入pic，比如123.png:\ncontent -posts --blog ---pic ----123.png ---article.md 之后，当我们在article.md中撰写文章时，用md语法来引用图片\n![替代文字](相对路径) 坑点就在这个相对路径上。\nvscode会提示你输入\n![alt](pic/123.png) 这是因为在vscode眼中，article.md只是一个文件而非文件夹。\n但是hugo编译静态文件的时候的逻辑可不是这样\n如果你这时用hugo server命令打开你的本地网页，会发现图片加载不出来（裂了），此时在新标签页打开这个图片会发现网址后缀为：\nposts/blog/article/pic/123.png 显然hugo是把article.md当成一个文件夹来看待了\n所以我们在选择路径时，应该先回到上一级目录，再进入pic文件夹：\n![alt](../pic/123.png) 再次hugo server命令即可看到生成在网页上的图片了\n图片居中与大小调整 md语法默认是图片是left-align的\n想要图片居中可以用html实现：\n\u0026lt;center\u0026gt;\u0026lt;img src=\u0026#34;../pic/123.png\u0026#34; width=\u0026#34;10%\u0026#34; /\u0026gt;\u0026lt;/center\u0026gt; center：居中图片\n相对路径：与上一节提到的一样\nwidth：调整图片大小\nhugo shortcodes hugo也提供了定制化功能shortcodes，具有多种可设定参数，也可自定义\n","permalink":"https://lysandert.github.io/posts/blog/blog_insert_pic/","summary":"折腾了半天，终于学会怎么在博客中插入图片了。 这里记录一下解决办法 插入图片：相对路径存在的问题 这是根目录结构： content -posts --blog 没有blog这一级结构的可以直接无视 当我们用hugo指令： hugo new posts/blog/article.md 生成新文章后hugo会自动在blog文件夹下面创建一个md文件： content -posts --blog ---article.md 我们需要的是生成一个与arti","title":"hugo博客 文内插入图片"},{"content":"Prerequisite 一个提供hk以外节点代理的vpn 注册一个chatgpt账号 vscode客户端（是不是很严谨？） 1.和2.可以参考国内自助获取chatgpt方法\n3.指路官网自行根据计算机型号下载\n下载与配置 打开vscode侧边栏的\u0026lt;拓展\u0026gt;，搜索chatgpt\n这里有很多自称为chatgpt的插件，我们下载图标是紫色的这个：\n下载后全局启用，重启vscode会在侧边栏发现这个选项：\n点击，会产生一个界面等你log in\n这时打开网址\n选择create new key-\u0026gt;copy\n最好把这个key保存下来，否则之后每次要重新生成\n再次打开vscode，点击log in，粘贴这个key即可开始与chatgpt对话\n这里提供两种方式：\n直接在对话框进行指示 选中一段代码，点击鼠标右键，可以看到有关chatgpt的指令 这里提供一些常用指令：\nBasic commands ChatGPT: Ad-hoc prompt Ad-hoc custom prompt prefix for the selected code. Right click on a selected block of code, run command. You will be asked to fill in your preferred custom prefix and the extension will remember that string for your subsequent ad-hoc queries.\nChatGPT: Add tests Write tests for you. Right click on a selected block of code, run command. \u0026ldquo;default\u0026rdquo;: \u0026ldquo;Implement tests for the following code\u0026rdquo;, \u0026ldquo;description\u0026rdquo;: \u0026ldquo;The prompt prefix used for adding tests for the selected code\u0026rdquo;\nChatGPT: Find bugs Analyze and find bugs in your code. Right click on a selected block of code, run command. \u0026ldquo;default\u0026rdquo;: \u0026ldquo;Find problems with the following code\u0026rdquo;, \u0026ldquo;description\u0026rdquo;: \u0026ldquo;The prompt prefix used for finding problems for the selected code\u0026rdquo;\nChatGPT: Optimize Add suggestions to your code to improve. Right click on a selected block of code, run command. \u0026ldquo;default\u0026rdquo;: \u0026ldquo;Optimize the following code\u0026rdquo;, \u0026ldquo;description\u0026rdquo;: \u0026ldquo;The prompt prefix used for optimizing the selected code\u0026rdquo;\nChatGPT: Explain Explain the selected code. Right click on a selected block of code, run command. \u0026ldquo;default\u0026rdquo;: \u0026ldquo;Explain the following code\u0026rdquo;, \u0026ldquo;description\u0026rdquo;: \u0026ldquo;The prompt prefix used for explaining the selected code\u0026rdquo;\nChatGPT: Add comments Add comments for the selected code. Right click on a selected block of code, run command. \u0026ldquo;default\u0026rdquo;: \u0026ldquo;Add comments for the following code\u0026rdquo;, \u0026ldquo;description\u0026rdquo;: \u0026ldquo;The prompt prefix used for adding comments for the selected code\u0026rdquo;\nChatGPT: Custom prompt 1 Your custom prompt 1. It\u0026rsquo;s disabled by default, please set to a custom prompt and enable it if you prefer using customized prompt \u0026ldquo;default\u0026rdquo;: \u0026ldquo;\u0026rdquo;,\nChatGPT: Custom prompt 2 Your custom prompt 2. It\u0026rsquo;s disabled by default, please set to a custom prompt and enable it if you prefer using customized prompt \u0026ldquo;default\u0026rdquo;: \u0026ldquo;\u0026rdquo;,\nOther available commands ChatGPT: Ask anything Free-form text questions within conversation window.\nChatGPT: Reset session Clears the current session and resets your connection with ChatGPT\nChatGPT: Clear conversation Clears the conversation window and resets the thread to start a new conversation with ChatGPT.\nChatGPT: Export conversation Exports the whole conversation in Markdown for you to easily store and find the Q\u0026amp;A list.\n注意：非代码问题 想问其他非代码问题，需要先在对话框键入\nChatGPT: Ask anything 即可开始提问\n","permalink":"https://lysandert.github.io/posts/blog/chatgpt_plugin_for_vscode/","summary":"Prerequisite 一个提供hk以外节点代理的vpn 注册一个chatgpt账号 vscode客户端（是不是很严谨？） 1.和2.可以参考国内自助获取chatgpt方法 3.指路官网自行根据计算机型号下载 下载与配置 打开vscode侧边栏的\u0026lt;拓展\u0026gt;，搜索chatgpt 这里有很多自称为chatgp","title":"VSCode ChatGPT插件"},{"content":"C++的堆操作一共两套体系：\nmake_heap和priority_queue\n前者是直接把原容器变成堆，类似于python中的heapq模块，\n后者是新建一个priority_queue类容器。\n默认都是大顶堆,默认的cmp都是less\u0026lt;\u0026gt;.\n想要小顶堆可以把val都加负号，也可以传入greater\u0026lt;\u0026gt;，同时也可以自定义：创建一个struct，或写一个cmp函数传入。\n1. make_heap 头文件： #include \u0026lt;algorithm\u0026gt; 堆操作方法-更底层，支持复杂度O(n)的直接建堆。 数据结构不改变，是直接将原先容器中的元素order变成符合堆定义的order 1.1 默认大顶堆，即cmp位置传入 \u0026#34;less\u0026lt;\u0026gt;{}\u0026#34; vector\u0026lt;int\u0026gt; v { 3, 2, 4, 1, 5, 9 }; // 建堆：传入iterator // make_heap(iterator::left, iterator::right, cmp = less\u0026lt;\u0026gt;); make_heap(v.begin(),v.end()); //默认max-heap // after make_heap, v: 9 5 4 1 2 3 // 弹出：先pop_heap再pop_back pop_heap(v.begin(),v.end()); // after pop_heap, v: 5 3 4 1 2 9 // 把堆顶元素放到堆尾去了 // 此时非堆尾元素构成一个堆 int top = v.back; // top = 9 v.pop_back(); // v仍然是一个vector\u0026lt;int\u0026gt;，支持pop_back // after removing the former top element, v: 5 3 4 1 2 // 压入：先push_back再push_pop v.push_back(6); push_heap(v.begin(),v.end()); 1.2 快捷改成小顶堆 1.2.1 先把数据都添加负号再建堆 1.2.2 cmp位置传入 \u0026#34;greater\u0026lt;\u0026gt;{}\u0026#34; make_heap(v1.begin(), v1.end(), greater\u0026lt;\u0026gt;{}); //注意pop_heap和push_heap时同样也要传 pop_heap(v1.begin(), v1.end(), greater\u0026lt;\u0026gt;{}); push_heap(v1.begin(), v1.end(), greater\u0026lt;\u0026gt;{}); 1.3 传入其他cmp自定义 2. priority_queue #include \u0026lt;queue\u0026gt; 封装的更好。但是不支持直接建堆。 数据结构改为优先队列类型,与vector\u0026lt;\u0026gt;接口不能共用。 2.1 默认是传入less\u0026lt;\u0026gt;，是最大堆 priority_queue\u0026lt;int\u0026gt; res; res.push(x); 2.2 可以传入greater\u0026lt;\u0026gt; 改成最小堆，或将数据添加负号 priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;\u0026gt; \u0026gt; res; res.push(x); // 或 priority_queue\u0026lt;int\u0026gt; res; res.push(-x); 2.3 自定义结构 struct S{ int key, val; //一定是重写 \u0026lt; 操作符！！ bool operator\u0026lt;(const \u0026amp;S other){ return val \u0026lt; other.val; // 或其他的判别方式，但反正大的那个意味着更高的优先级 } priority_queue\u0026lt;S\u0026gt; res; res.push({key,val});//此时便会自动用S中重写的\u0026lt;当作cmp函数去排序 } 3. topK问题 想要找到数组中第k或前k大元素，可以用heap来解决（当然也有其他更好的办法例如用快排的partition可以实现O(n)的复杂度，这里不再赘述）\n一. 维护n个元素的堆 直接建max-heap，然后弹出来k个\n复杂度为O(n + klgn)\n二. 维护k个元素的堆 对前k个建min-heap。后面的每个与堆顶比较，把大的留在堆里，这样最后就剩下了前k个最大的元素，第k个就是堆顶那个。\n复杂度为O(k + (n-k)lgk) 或者 O(nlgk)\n(主要是看前k个是直接建堆还是插入建堆)\n","permalink":"https://lysandert.github.io/posts/blog/c++_heap%E7%94%A8%E6%B3%95/","summary":"C++的堆操作一共两套体系： make_heap和priority_queue 前者是直接把原容器变成堆，类似于python中的heapq模块， 后者是新建一个priority_queue类容器。 默认都是大顶堆,默认的cmp都是less\u0026lt;\u0026gt;. 想要小顶堆可以把val都加负号，","title":"C++ STL heap用法"},{"content":"1. hugo 在hugo中根据指示，下载hugo, go, git.\n根据指示可以创建一个demo熟悉操作：\nhugo new your_site_name cd your_site_name hugo server 然后打开浏览器输入\u0026lt;http://localhost:1313/\u0026gt;即可浏览网站 (虽然现在什么也没有) 需要注意的是，macos下载go之后可能仍然会对相关指令报错：\ncommand not found: go 按照这个链接添加PATH即可解决\n也可以去中文站点获得更流畅的阅读体验。\n2. github pages github提供无需付费，无需备案的网站部署方案：git pages.\n为了使给给每个人的url互斥，github的解决方案是，让网站名必须与用户名完全一样。\n我们需要做的只是：\n注册一个github账号 在github中创建一个新的仓库，名字为\u0026lt;你的用户名\u0026gt;.github.io 3. themes 接下来，可以去https://themes.gohugo.io/挑选你喜欢的主题，也可以去github挑选star数较高的主题。hugo的社区总体来说比较成熟。\n这里推荐两个主题：\nacademic 适合于学术主页\nPaperMode 适合于个人博客\n当选好了主题之后，要将主题应用到我们的网站上来。\n这里提供两个方案：\n1. 直接用，本人采取的就是这个 git clone \u0026lt;https/ssh of the theme\u0026gt; git submodule update --init --recursive 2. 把他当作一个主题，主要是为了防止以后想换主题 hugo new site_name cd site_name/themes git clone \u0026lt;http/ssh of the theme\u0026gt; git submodule update --init --recursive 不熟悉git操作的话可以自行google或者参考git command\n之后，可以用命令来创建新文章\nhugo new article_name.md 这个article.md会被默认放入content文件夹中\n用vscode或者其他md编辑器打开此文件后便可以快乐的写文章了\n具体的工作流可以参考：workflow\n更多操作，请阅读主题的README文件进行配置\n4. 网站部署 理论上说，只要把site的子文件夹public中的文件（hugo生成的网页文件）都push到github上即可。\nhugo生成的site本身是一个repo，而git不允许其子文件夹public也成为一个repo。然而，我们必须得让public与\u0026lt;你的名字\u0026gt;.github.io仓库建立连接，这里我提供两种解决方案：\n1. 删除site本身的.git文件(直接在图形界面操作)， 然后将public初始化为git仓库并与\u0026lt;你的用户名\u0026gt;.github.io连接： cd name_of_your_site hugo cd public git remote add origin \u0026lt;ssh or https of your repo\u0026gt; 这里推荐使用ssh，原因是可以自行配置（具体自己查）使得不用每次都输入密码 2. 使\u0026lt;你的用户名\u0026gt;.github.io成为site的submodule，详见 \u0026lt;https://www.atlassian.com/git/tutorials/git-submodule\u0026gt; cd name_of_your_site git submodule add -f -b master \u0026lt;https or ssh of your repo\u0026gt; public 如果想要更方便一点的话，建议选择第一种方案。\n接下来要将hugo生成的本地文件推到github仓库中进行部署\n1. 如果你用的是第一种方案 cd name_of_your_site/public git push 2. 如果你是第二种 cd name_of_your_site git add --all git commit -m \u0026#34;write something\u0026#34; git push 之后打开https://你的用户名.github.io就可以欣赏你自己的博客了\n如果显示404或者博客内容未更新，请清除浏览器缓存或等一会儿。\n","permalink":"https://lysandert.github.io/posts/blog/blog_setup/","summary":"1. hugo 在hugo中根据指示，下载hugo, go, git. 根据指示可以创建一个demo熟悉操作： hugo new your_site_name cd your_site_name hugo server 然后打开浏览器输入\u0026lt;http://localhost:1313/\u0026gt;即可浏览网站 (虽然现在什么也没有) 需要注意的是，macos下载go之后可能仍然会对相关指令报错： command not found: go 按","title":"【个人网站搭建】hugo + github pages"},{"content":"1.新建文档 新建 markdown文档 类型：blog/research/read/life\ncd ~/Documents/myBlogs hugo new posts/blog/\u0026lt;article_name\u0026gt;.md 2. 写作 打开vsc进行md编辑，实时渲染。\n也可以在用热键command+S保存后在bash中输入：\nhugo server -D 在浏览器中打开 http://localhost:1313/ 即可在本地浏览博客生成情况\n写作完毕后，记得添加tags方便查询与归档\n也可以添加keywords便于搜索引擎爬取\n3. 上传remote cd myBlogs hugo -F --cleanDestinationDir cd public git add . git commit -m \u0026#34;sth“ git push 文章会自动上传到 http://lysandert.github.io\n","permalink":"https://lysandert.github.io/posts/blog/blog_workflow/","summary":"1.新建文档 新建 markdown文档 类型：blog/research/read/life cd ~/Documents/myBlogs hugo new posts/blog/\u0026lt;article_name\u0026gt;.md 2. 写作 打开vsc进行md编辑，实时渲染。 也可以在用热键command+S保存后在bash中输入： hugo server -D 在浏览器中打开 http://localhost:1313/ 即可在本地浏览博客生成情况 写作完毕后，记得添加tags方便查询与","title":"Blog Workflow"},{"content":"basic initialize local repository\ngit init make untracked file tracked\ngit add [file] git add . # add all git add --all git add -A commit changes\ngit commit -m \u0026#34;message\u0026#34; view current information about git\ngit status clone from the github\ngit clone ssh/https git clone -b branch_name ssh/https show commit logs\ngit log reset current HEAD to specified state\n# this commend will delete logs along the way git reset --hard HEAD^ #last git reset --hard HEAD^^ #the time before last time git reset --hard HEAD~3 git reset --hard commit_id revert to existing commits\n# this commend will not delete any log git revert -n HEAD^ #last git revert -n HEAD^^ #the time before last time git revert -n HEAD~3 git revert -n commit_id branch create new branch\ngit checkout -b branch_name switch to another branch\ngit check branch_name merge into current branch\ngit merge branch_name # (merge from) to the current branch (do not need to state) undo the merge\ngit merge --abort merge\nremote repository set a new remote repo\ngit remote add origin [https or ssh] # origin is the default name of remote repo view current remote repo\ngit remote git remote -v change url\ngit remote set-url [https or ssh] 拉取远程仓库(pull the changes from the remote)\ngit pull git pull origin branch_name \u0026gt;\u0026gt;\u0026gt; Already up to date. upload\ngit push -u origin master # first time git push origin master git push remote_name local_branch_name git push pull request fork the public repo clone it to the local create new branch push it to the remote create pull request and wait for the acceptance ","permalink":"https://lysandert.github.io/posts/blog/git_command/","summary":"basic initialize local repository git init make untracked file tracked git add [file] git add . # add all git add --all git add -A commit changes git commit -m \u0026#34;message\u0026#34; view current information about git git status clone from the github git clone ssh/https git clone -b branch_name ssh/https show commit logs git log reset current HEAD to specified state # this commend will delete logs along the way git reset --hard HEAD^ #last git reset --hard HEAD^^ #the time before last time git reset --hard HEAD~3 git reset --hard commit_id revert to existing commits # this commend will not delete any log git revert -n HEAD^ #last git revert -n HEAD^^ #the time before last time git revert -n HEAD~3 git revert -n commit_id branch create new branch git checkout -b branch_name switch to another branch git check","title":"git commands"},{"content":"一.购买代理服务 即梯子，vpn，whatever。可以帮助你将ip地址包装成其他国家/地区，从而打开比如维基百科、chatgpt等学习网站。\n已有代理服务的可以直接看下一节内容。如果觉得自己的梯子速度比较快的话也可以选择推荐给我。\n没有的可以尝试自行搜索。考虑到百度现在ban了包括但不限于vpn,vnp,代理等关键词，实在搜不到的话可以尝试我的这个：https://user.viptwo.xyz\n照着网址的说明去一步步做即可。\n这个代理的花费是30CNY/月，again，如果有更好的选择请推给我。\n二.购买接码服务 这一步主要是chatgpt限制只有国外手机号可以注册。\n既然你已经完成了第一步，那么便可以打开全局代理，自行用谷歌搜索接码服务了。\n或者也可以尝试我之前用的这个：https://sms-activate.org\n界面长这样：\n默认是英语，可以选择先在右上角的ENG那里改成中文版\n然后在右上角点击注册，注册完了就登录，登录完了右上角会出现余额。点进去充值。\n理论上购买一次接码服务只需要CNY1，但是它只允许充值美元，所以我们选择充值1美元，可选支付宝(AliPay)支付，大概CNY7。\n充值完了之后返回首页，在左边栏找到OpenAi，也就是研发出chatgpt的那个公司。\n点击OpenAi，然后选个国家，美日印新都可以，注意别买标注了\u0026lt;虚拟\u0026gt; 的就行，点击购物车图标进行购买。\n之后会跳转页面并显示你购买的手机号。\n三. 注册chatgpt账号 首先开启全局代理服务，选择非国内地区（hk也不行），然后打开openai 或https://openai.com/api/\n点击右上角sign up进行注册。谷歌、微软账号或者邮箱注册都可以\n按照提示去做，会跳到一步让你输入手机号，这时我们将第二步中购买的接码服务中的手机号复制粘贴过来\n稍后会让你填写验证码，这时接码网站那里会显示它手机收到的验证码，同样复制粘贴过来即可。\n注册成功后进入chatgpt 或 https://chat.openai.com/auth/login即可登录\n登录完选择personal use即可在底部对话框与chatgpt进行对话了\n四.第三步可能遇到的问题 1.接码服务过期了 一般的接码服务都是有限时的，所以过期很正常。只需要返回第二步再购买一次即可，因为我们之前充值的是1美元，所以大概可以买5-6次\n2. 不服务您所在的国家/at capacity 首先检查代理是否开启（比如看看google.com能不能正确搜索），是否使用了香港节点。\n如果还是不行，这里提供3种解决办法，请挨个试一遍\n1）清除浏览器缓存，然后刷新页面 怎么清除浏览器缓存，建议自己搜一下对应的浏览器操作\n2）在新标签页打开无痕模式，然后重新打开chatgpt并登录 3）按如下指示操作 复制下面这段代码：\nwindow.localStorage.removeItem(Object.keys(window.localStorage).find(i=\u0026gt;i.startsWith('@@auth0spajs'))) 然后在浏览器网址栏 键入 ：\njavascript: 然后将代码粘贴进去，接着刷新\n4）如果还是不行，请等几天，它可能确实服务器崩了或者在变相强迫你买plus ","permalink":"https://lysandert.github.io/posts/blog/chatgpt_setup/","summary":"一.购买代理服务 即梯子，vpn，whatever。可以帮助你将ip地址包装成其他国家/地区，从而打开比如维基百科、chatgpt等学习网站。 已有代理服务的可以直接看下一节内容。如果觉得自己的梯子速度比较快的话也可以选择推荐给我。 没有的可以尝试自行搜索。考虑到百度现在ban了包括但","title":"国内获取账号、访问chatGPT"},{"content":"1. apt/apt-get update失败 1.1 尝试换源 命令行里输入\nnano /etc/apt/sources.list 在打开的编辑器里将原有的源注释。\n打开firefox搜索中科大/阿里/清华源（记得一定要与ubuntu的版本对应），复制并粘贴到编辑器中。\n例如：清华源for ubuntu 20.04 LTS\n# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse 1.2 /ubuntu/改为/ubuntu-ports/ 网上的源多未标明cpu架构，大多是默认x86架构。\n但实际上不同cpu架构对应的源可能不同\n如arm64架构的源应该将ubuntu改为ubuntu-ports\ndeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal main restricted universe multiverse 1.3 https改为http http普遍响应比较快，HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。\n例如\ndeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal main restricted universe multiverse 1.4 清除缓存 特别是当卡在\u0026quot;waiting for the headers\u0026quot;时\n详情可见：https://askubuntu.com/questions/156650/apt-get-update-very-slow-stuck-at-waiting-for-headers\n","permalink":"https://lysandert.github.io/posts/blog/ubuntu_bug/","summary":"1. apt/apt-get update失败 1.1 尝试换源 命令行里输入 nano /etc/apt/sources.list 在打开的编辑器里将原有的源注释。 打开firefox搜索中科大/阿里/清华源（记得一定要与ubuntu的版本对应），复制并粘贴到编辑器中。 例如：清华源for ubuntu 20.04 LTS # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse #","title":"linux(ubuntu)常见bug解决"},{"content":"","permalink":"https://lysandert.github.io/posts/research/research1/","summary":"","title":"Research1"},{"content":"进程与线程\n进程 Process 进程的状态 运行状态（Running）：该时刻进程占用 CPU； 就绪状态（Ready）：可运行，由于其他进程处于运行状态而暂时停止运行； 阻塞状态（Blocked）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行； 创建状态（new）：进程正在被创建时的状态； 结束状态（Exit）：进程正在从系统中消失时的状态； 挂起状态：\n阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现； 就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行； 为什么挂起：\n节省物理内存 sleep让进程间歇挂起（定时器） 用户希望挂起一个程序的执行 PCB 进程控制块：进程存在的唯一标识。一般选择链表来组织。\nCPU的上下文切换 CPU 上下文切换就是先把前一个任务的 CPU 上下文（CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。\n系统内核会存储保持下来的上下文信息，当此任务再次被分配给 CPU 运行时，CPU 会重新加载这些上下文，这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。\n可分为：\n进程上下文切换 线程上下文切换 中断上下文切换 进程的上下文切换 一个进程切换到另一个进程运行，称为进程的上下文切换。发生在内核态。\n进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。\n常见场景：\n为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行； 进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行； 当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度； 当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行； 发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序； 线程 Thread 进程中的一条执行流程\n共享：同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源。\n独立：但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。\n优点：\n一个进程中可以同时存在多个线程； 各个线程之间可以并发执行； 各个线程之间可以共享地址空间和文件等资源； 缺点：\n对C++来说，进程中的一个线程崩溃会导致其所属进程的所有进程都崩溃 线程的上下文切换 当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样； 当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据； 线程的实现方式 用户级线程模型（User Thread）：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理； 内核级线程模型（Kernel Thread）：在内核中实现的线程，是由内核管理的线程； 轻量级进程模型（LightWeight Process）：在内核中来支持用户线程； 用户线程与内核线程的对应关系：多对一，一对一，一对多\n用户级线程模型 （多对一）\n1.由应用程序所支持的线程实现, 内核意识不到用户级线程的实现。\n用户线程是基于用户态的线程管理库来实现的，那么线程控制块（Thread Control Block, TCB） 也是在库里面来实现的，对于操作系统而言是看不到这个 TCB 的，它只能看到整个进程的 PCB。\n所以，用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。\n优点：\n每个进程都需要有它私有的线程控制块（TCB）列表，用来跟踪记录它各个线程状态信息（PC、栈指针、寄存器），TCB 由用户级线程库函数来维护，可用于不支持线程技术的操作系统； 用户线程的切换也是由线程库函数来完成的，无需用户态与内核态的切换，所以速度特别快；、 （optional）允许每个进程定制自己的调度算法，线程管理比较灵活。这就是必须自己写管理程序，与内核线程的区别 缺点：\n由于操作系统不参与线程的调度，如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行了。 当一个线程开始运行后，除非它主动地交出 CPU 的使用权，否则它所在的进程当中的其他线程无法运行，因为用户态的线程没法打断当前运行中的线程，它没有这个特权，只有操作系统才有，但是用户线程不是由操作系统管理的。 由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会比较慢； 内核级线程模型 （一对一）\n内核线程的优点：\n多处理器系统中，内核能够并行执行同一进程内的多个线程 在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行/能够切换同一进程内的其他线程继续执行（用户级线程的一个缺点）； 分配给线程，多线程的进程获得更多的 CPU 运行时间； 内核线程的缺点：\n在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如 PCB 和 TCB； 线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大； 轻量级线程模型 LWP 内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持，而且 LWP 是由内核管理并像普通进程一样被调度。\n在大多数系统中，LWP与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息。一般来说，一个进程代表程序的一个实例，而 LWP 代表程序的执行线程，因为一个执行线程不像进程那样需要那么多状态信息，所以 LWP 也不带有这样的信息。\n基于内核线程。但也可以使用用户线程。\nLWP与用户线程的对应关系\n1：1 N：1 M：N 混搭 进程与线程的比较 进程是资源（包括内存、打开的文件等）分配/拥有的基本单位，线程是 CPU 调度的基本单位； 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈； 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系； 线程能减少并发执行的时间和空间开销； 当进程只有一个线程时，可以认为进程就等于线程； 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，这些资源在上下文切换时是不需要修改的； 线程能减少开销体现在：\n线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们； 线程的终止时间比进程快，因为线程释放的资源相比进程少很多； 同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的； 由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了； 进程调度算法 调度时机 从就绪态 -\u0026gt; 运行态：当进程被创建时，会进入到就绪队列，操作系统会从就绪队列选择一个进程运行； 从运行态 -\u0026gt; 阻塞态：当进程发生 I/O 事件而阻塞时，操作系统必须选择另外一个进程运行； 从运行态 -\u0026gt; 结束态：当进程退出结束后，操作系统得从就绪队列选择另外一个进程运行； 调度原则 CPU 利用率：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率； 系统吞吐量：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量； 周转时间：周转时间是进程运行+阻塞时间+等待时间的总和，一个进程的周转时间越小越好； 等待时间：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意； 响应时间：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。 调度算法 如果硬件时钟提供某个频率的周期性中断，那么可以根据如何处理时钟中断 ，把调度算法分为两类：\n非抢占式调度算法挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情。 抢占式调度算法挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便把 CPU 控制返回给调度程序进行调度，也就是常说的时间片机制。 单核CPU 先来先服务（First Come First Serve, FCFS)：适用于CPU繁忙型作业的系统，但不适用于I/O繁忙型作业的系统。\n最短作业优先（Shortest Job First, SJF)：有助于提高吞吐量，但会使长作业的周转时间变长或不会运行。\n高响应比优先（Highest Response Ratio Next)：理想型算法，现实中实现不了，因为无法预知要求服务时间。权衡短与长作业。优先权=（等待时间+要求服务时间）/要求服务时间。\n时间片轮转（Round Robin，PR）：众生平等，但有时间片\n最高优先级（Highest Priority First）：\n静态优先级和动态优先级 非抢占式和抢占式 多级反馈（Multilevel Feedback Queue)：时间片轮转和最高优先级的综和发展\n「多级」表示有多个队列（每个队列中有多个进程），每个队列优先级从高到低，同时优先级越高时间片越短。 「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列； 设置了多个队列，赋予每个队列不同的优先级，每个队列优先级从高到低，同时优先级越高时间片越短； 新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果其在第一级队列规定的时间片内没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成； 当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行； 多核CPU Linux中每个CPU都有自己的运行队列（排序即为优先级）：\ndl_rq rt_rq cfs_rq：红黑树实现 各种调度器和调度策略\nCFS（完全公平调度）：优先选择vruntime少的任务\nvruntime = 实际运行时间delta_exec * NICE_0_LOAD/权重\n","permalink":"https://lysandert.github.io/posts/blog/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/","summary":"进程与线程 进程 Process 进程的状态 运行状态（Running）：该时刻进程占用 CPU； 就绪状态（Ready）：可运行，由于其他进程处于运行状态而暂时停止运行； 阻塞状态（Blocked）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也","title":"进程与线程"},{"content":" a, b are of same type: a += b only needs 1 assignment, it\u0026rsquo;s like [pass by reference]\nbut for a = a + b, the process is as follows:\ntemp = a a = temp + b it\u0026rsquo;s take 2 assignment.\nwhen a, b are strings, the problem is especially obvious.\na, b are of different types a += b can do implicit typecasting but a = a + b cannot\n","permalink":"https://lysandert.github.io/posts/blog/why_use_a+b/","summary":"a, b are of same type: a += b only needs 1 assignment, it\u0026rsquo;s like [pass by reference] but for a = a + b, the process is as follows: temp = a a = temp + b it\u0026rsquo;s take 2 assignment. when a, b are strings, the problem is especially obvious. a, b are of different types a += b can do implicit typecasting but a = a + b cannot","title":"Why use a+=b instead of a = a + b in C++?"},{"content":"硬件结构 冯诺伊曼模型 运算器ALU 控制器Control Unit 存储器Memory Unit 输入输出设备 I/O devices 内存 线性存储，基本单位字节(Byte)，每一个字节对应一个内存地址（从0开始编号，最后一个地址是内存总字节数-1）。 1 Byte = 8 bit\nCPU 控制单元Control Unit 逻辑运算单元ALU 寄存器Accumulator 32位CPU=32bit=一次可计算4字节\n寄存器 通用寄存器：存放需要计算的数据 程序计数器：存放下一条指令所在的“地址”（指令还在内存中） 指令寄存器：用来存放当前正在执行的指令 总线 用于CPU和内存、其他设备之间的通信，总线可分为三种：\n地址总线，指定CPU将要操作的内存的地址 控制总线，用于发射、接收信号，如终端、复位等信号。 数据总线，用于读取内存的数据 读写内存数据时：一般先地址总线指定地址，再控制总线决定是读或写命令，再通过数据总线来传输数据。\n位宽 线路位宽：地址总线条数\n32位宽的地址总线和数据总线最好对应32位cpu。32位最大可操作2^32B（4GB）内存（寻址范围）。\n64位CPU可以一次读入64位数字或进行64位数字运算。而32位则需要进位等操作。\n只有运算大数字时，64位的计算性能才体现出来。\n硬件的位宽一般指CPU的位宽，软件的位宽一般指指令的位宽。\n64位操作系统经过兼容可以运行32位的软件。但32位的软件却难以执行64位的指令，因为32位的寄存器存不下64位指令。\nCPU的指令周期 第一步，CPU 读取「程序计数器」的值，这个值是指令的内存地址，然后 CPU 的「控制单元」操作「地址总线」指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过「数据总线」将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令数据存入到「指令寄存器」。 第二步，「程序计数器」的值自增，表示指向下一条指令。这个自增的大小，由 CPU 的位宽决定，比如 32 位的 CPU，指令是 4 个字节，需要 4 个内存地址存放，因此「程序计数器」的值会自增 4； 第三步，CPU 分析「指令寄存器」中的指令，确定指令的类型和参数，如果是计算类型的指令，就把指令交给「逻辑运算单元」运算；如果是存储类型的指令，则交由「控制单元」执行； 简单总结一下就是，一个程序执行的时候，CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。\nCPU 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个不断循环的过程被称为 CPU 的指令周期。\n存储器层次结构 寄存器：最快。32/64位CPU的寄存器大多可以存储4/8个字节。\nCPU cache: SRAM 静态随机存储器\n内存：DRAM 动态随机存储器\n硬盘：SSD 固体硬盘或者 HDD 机械硬盘\nCPU Cache L1 一般分为数据缓存dCache和指令iCache缓存两个\nL1、L2是每个CPU核心独有，L3是多个CPU共享\nCache line缓存块是CPU从内存读取数据到Cache的单位\n缓存命中率 提高数据缓存命中率：按内存布局顺序访问 提高指令缓存命中率：与CPU分支预测器有关，C/C++提供有显式的分支预测工具likely和unlikely（用其将if中的条件包裹起来就好）。 提高多核缓存命中率：把线程绑定到一个CPU核心上。如Linux的Sched_setaffinity方法 数据读写 写入的方法：写直达和写回（大多情况无需读写内存，更好）\n缓存一致性 Cache Coherence 写传播 事务的串行化（锁的概念） 总线嗅探 写传播的实现方式，不能实现事务串行化，总线带宽压力大（总是发出广播事件）\nMESI协议 Modified 相当于Dirty Exclusive Shared Invalidated 伪共享（读写数据时的问题） 当多个线程（分属多个CPU核心）同时读写同一个Cache Line的不同变量时，会导致CPU Cache失效。\n解决办法：\nLinux 的 __cacheline_aligned 放在变量后面可使对齐 用不会更改的变量（可以是无意义的）去填充 中断 异步的事件处理机智，可以提高系统的并发处理能力。\n中断处理程序，要尽快处理完，减少对正常进程运行调度的影响（其他中断可能会丢失）。\nLinux：中断分为两个阶段（为了解决中断程序执行过长和中断丢失问题）\ntodo ","permalink":"https://lysandert.github.io/posts/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/","summary":"硬件结构 冯诺伊曼模型 运算器ALU 控制器Control Unit 存储器Memory Unit 输入输出设备 I/O devices 内存 线性存储，基本单位字节(Byte)，每一个字节对应一个内存地址（从0开始编号，最后一个地址是内存总字节数-1）。 1 Byte = 8 bit CPU 控制单元Control Unit 逻辑运算单元ALU 寄存器Accumul","title":"计算机硬件结构"},{"content":"内存管理 虚拟内存 操作系统引入了虚拟内存的概念\n程序所使用的内存地址叫做虚拟内存地址（Virtual Memory Address） 实际存在硬件里面的空间地址叫物理内存地址（Physical Memory Address）。 内存分段 Segmentation driven: 用户执行的程序（虚拟内存中），在物理内存中找一块地方放（段的大小不固定）\n虚拟地址通过段表与物理地址进行映射。\n虚拟地址切分为：段选择因子和段内偏移量：\n段选择子就保存在段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。 虚拟地址中的段内偏移量应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。 分段会产生外部内存碎片\n解决外部内存碎片：内存交换 —— 先把内存碎片中间的东西交换到硬盘上，再从硬盘上拿回到内存（放在两侧，使外部内存碎片得以合并）\n但是！这样效率比较低，因为硬盘访问速度太慢了！\n内存分页 Paging driven：把虚拟内存和物理内存切分成很多个固定大小的页，比如一片4kb\n分页不会产生外部碎片，因为它可以将连续的虚拟地址映射为不连续的物理地址。\n但是分页可能产生内部碎片。例如当程序不足一页大小时，还是会给它分配一页。\n当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。\n如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。一旦需要的时候，再加载进来，称为换入（Swap In）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。\n分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。\n虚拟地址切分为：页表和页内偏移量\n多级页表 如果页表只有一级，由于页表项比段表项更多，那么占用内存会更多。每个进程都有自己的虚拟地址空间，也就是说都有自己的页表，使差距继续几何倍数增长。\n可以用多级页表来解决。由于局部性原理，如何某个n级页表没有被用到，你那么便无需创建其的n+1级页表。\n64位系统一般由四级目录：\n全局页目录项 PGD（Page Global Directory）； 上层页目录项 PUD（Page Upper Directory）； 中间页目录项 PMD（Page Middle Directory）； 页表项 PTE（Page Table Entry）； TLB 在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB（Translation Lookaside Buffer） ，通常称为页表缓存、转址旁路缓存、快表等。\n在 CPU 芯片里面，封装了内存管理单元（Memory Management Unit）芯片，它用来完成地址转换和 TLB 的访问与交互。\n有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。\nTLB 的命中率很高，因为程序最常访问的页就那么几个。\n段页式 将分段和分页结合。\n段页式内存管理实现的方式：\n先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制； 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页； 地址结构由段号、段内页号和页内位移三部分组成。\n","permalink":"https://lysandert.github.io/posts/blog/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","summary":"内存管理 虚拟内存 操作系统引入了虚拟内存的概念 程序所使用的内存地址叫做虚拟内存地址（Virtual Memory Address） 实际存在硬件里面的空间地址叫物理内存地址（Physical Memory Address）。 内存分段 Segmentation driven: 用户执行的程序（虚拟内存中），在物理内存中找一块地方放（段的大小不固定） 虚拟","title":"Linux内存管理"},{"content":"","permalink":"https://lysandert.github.io/posts/life/life/","summary":"","title":"Life"},{"content":"","permalink":"https://lysandert.github.io/posts/read/read/","summary":"","title":"Read"},{"content":"\u0026lt;div\u0026gt; test test test \u0026lt;/div\u0026gt; std::string = \u0026#34;test\u0026#34;; unique_ptr(new string(\u0026#34;t\u0026#34;)); ","permalink":"https://lysandert.github.io/posts/research/research/","summary":"\u0026lt;div\u0026gt; test test test \u0026lt;/div\u0026gt; std::string = \u0026#34;test\u0026#34;; unique_ptr(new string(\u0026#34;t\u0026#34;));","title":"Research"},{"content":" Lysander\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Lysander\u0026rsquo;s Blog 网址： https://lysandert.github.io 图标： https://lysandert.github.io/img/cai.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n","permalink":"https://lysandert.github.io/links/","summary":"Lysander\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Lysander\u0026rsquo;s Blog 网址： https://lysandert.github.io 图标： https://lysandert.github.io/img/cai.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内","title":"🤝友链"},{"content":" 🐼 About me 😎 Name: Lysander Cheng 🎓 Educational experience Sophomore(2021.9-2025.8): Computer Science and Engineering, Chinese University of Hong Kong, Shenzhen. Github: https://github.com/LysanderT 🌱 Research interest: SLAM, AIGC \u0026amp; Emergence 🦾 I\u0026rsquo;m learning SLAM, computer network \u0026amp; OS 👍 I’m looking for a summer internship(research or work) ","permalink":"https://lysandert.github.io/about/","summary":"🐼 About me 😎 Name: Lysander Cheng 🎓 Educational experience Sophomore(2021.9-2025.8): Computer Science and Engineering, Chinese University of Hong Kong, Shenzhen. Github: https://github.com/LysanderT 🌱 Research interest: SLAM, AIGC \u0026amp; Emergence 🦾 I\u0026rsquo;m learning SLAM, computer network \u0026amp; OS 👍 I’m looking for a summer internship(research or work)","title":""}]